package uce.project.com.database.daos;

import uce.project.com.cat.anotations.*;
import uce.project.com.database.entities.User;

import java.util.List;

@Dao
public interface UserDao{
    @Query("select * from User")
    public List<User> getAll();
    @Query("select * from User where gender=true order by name")
    public List<User> getGenderTrue();
    @Query("select * from User where id = :id")
    public List<User> getById(@P("id") Integer id);
    @Insert
    public boolean insertUser(User user);
    @Update
    public boolean updateUser(User user);
    @Delete boolean deleteUser(User user);
}
package uce.project.com.database.entities;
import lombok.*;
import uce.project.com.cat.anotations.Entity;
import uce.project.com.cat.anotations.PrimaryKey;
import uce.project.com.cat.anotations.ColumnInfo;


@Getter
@ToString
@Builder
@NoArgsConstructor
@AllArgsConstructor
@Entity("User")
public class User {
    @ColumnInfo(name="id")
    @PrimaryKey(autoIncrement = true)
    private Integer id;
    @ColumnInfo(name="name", params = "255")
    private String name;
    @ColumnInfo(name = "apellido", params = "255")
    private String apellido;
    @ColumnInfo(name = "gender")
    private Boolean gender;
}
// esto es solo de contexto para que puedas explicar bien como crear las entidades y los daos 
package uce.project.com.cat.anotations;

import uce.project.com.cat.SqlColumnInfo;
import uce.project.com.cat.types.SqlTypes;
import uce.project.com.cat.types.inter.IDataType;

import java.sql.*;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.atomic.AtomicReference;

public interface TableActions {
    static String getSql(Class<?> entity)
    {
        Map<String, SqlColumnInfo> map = new HashMap<>();
        Entity entityAnotation = entity.getAnnotation(Entity.class);

        if(entityAnotation == null) throw new RuntimeException(entity.getName() + "Must have Entity anotation");
        if(entityAnotation.value().trim().isEmpty()) throw new RuntimeException(entity.getName()+ "Must not be empty");
        var fields = entity.getDeclaredFields();
        Arrays.stream(fields).forEach(field ->{
            AtomicReference<String> key = new AtomicReference<>();
            AtomicReference<SqlColumnInfo.Builder> builder = new AtomicReference<>(SqlColumnInfo.builder());
            Class<?> fieldType = field.getType();
            IDataType dataType = SqlTypes.get(fieldType);

            builder.set(builder.get().type(dataType));

            Arrays.stream(field.getAnnotations()).forEach(annotation -> {
                if(annotation.annotationType().equals(ColumnInfo.class))
                {
                    ColumnInfo columnInfo = (ColumnInfo) annotation;
                    builder.set(builder.get().columnName(columnInfo.name()).params(columnInfo.params()));
                    key.set(columnInfo.name());
                    return;
                }
                if(annotation.annotationType().equals(PrimaryKey.class))
                {
                    PrimaryKey pk = (PrimaryKey) annotation;
                    builder.set(builder.get().isPrimaryKey(true).autoIncrement(pk.autoIncrement()));
                }
            });
            map.put(key.get(), builder.get().build());
        });
        StringBuilder sqlCreate = new StringBuilder();

        sqlCreate.append(String.format("CREATE TABLE %s(", entityAnotation.value()));
        var keys = map.keySet();
        var keyList = new java.util.ArrayList<>(keys.stream().toList());
        Collections.reverse(keyList);
        for(var key : keyList)
        {
            sqlCreate.append("\n");
            SqlColumnInfo cInfo = map.get(key);
            sqlCreate.append(String.format(cInfo.columnName()));
            sqlCreate.append(" ");
            sqlCreate.append(String.format(cInfo.type().sqlType(), cInfo.params()));
            sqlCreate.append(cInfo.isPrimaryKey()? " PRIMARY KEY" : "");
            sqlCreate.append(cInfo.autoIncrement()? " AUTO_INCREMENT":"");
            sqlCreate.append(",");
        }
        sqlCreate = new StringBuilder(sqlCreate.substring(0, sqlCreate.length() - 1));
        sqlCreate.append("\n");
        sqlCreate.append(");");
        System.out.println(sqlCreate);
        return sqlCreate.toString();
    }
    public static boolean doesTableExist(Connection connection, String tableName) throws SQLException {
        DatabaseMetaData dbMeta = connection.getMetaData();
        try (ResultSet rs = dbMeta.getTables(null, null, tableName, new String[] {"TABLE"})) {
            return rs.next();
        }
    }
    static boolean dropTable(Connection connection, String tableName)
    {
        System.out.println(tableName);
        String sql = "DROP TABLE IF EXISTS " + tableName;
        try (Statement stmt = connection.createStatement()) {
            stmt.executeUpdate(sql);
            return true;
        } catch (SQLException e) {
            e.printStackTrace();
            return false;
        }
    }
}

package uce.project.com.cat.proxy.handlers;

import com.google.j2objc.annotations.OnDealloc;
import uce.project.com.cat.Cat;
import uce.project.com.cat.anotations.*;

import java.lang.reflect.*;
import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;
import java.util.Optional;

public class DaoHandler implements InvocationHandler {
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        if(method.isAnnotationPresent(Query.class)) return getMany(proxy, method, args);
        else if(method.isAnnotationPresent(Insert.class) && args.length == 1) return insertOne(proxy,method, args);
        else if(method.isAnnotationPresent(Update.class) && args.length == 1) return updateOne(proxy, method, args);
        else if(method.isAnnotationPresent(Delete.class) && args.length == 1) return deleteOne(proxy,method,args);
        throw new RuntimeException(method.getName() +  " error make sure your dao implementation is right");
    }

    private Object updateOne(Object proxy, Method method, Object[] args) throws Exception {
        if(args.length != 1) throw new RuntimeException(method.getName()+ " must receive just one parameter");
        var item = args[0];
        if(item == null) throw new RuntimeException("The parameter of " + method.getName() + "doesn't have to be null");
        if(!item.getClass().isAnnotationPresent(Entity.class)) throw new RuntimeException(" the parameter of " + method.getName() + " needs to be an entity");
        var tableName = item.getClass().getAnnotation(Entity.class).value();
        var declaredFields = item.getClass().getDeclaredFields();
        Connection connection = Cat.getConnection();
        StringBuilder builder = new StringBuilder();
        StringBuilder builderWhere = new StringBuilder();
        builder.append(String.format("UPDATE %s SET ", tableName));
        Optional<Object> primaryKey = Optional.empty();
        List<Object> params= new ArrayList<>();
        for(var declaredField : declaredFields)
        {
            declaredField.setAccessible(true);
            var value = declaredField.get(item);
            if(declaredField.isAnnotationPresent(PrimaryKey.class))
            {
                var pkAnotation = declaredField.getAnnotation(PrimaryKey.class);
                var columName = declaredField.getAnnotation(ColumnInfo.class).name();
                if (value == null) throw new RuntimeException("CatORM needs an ID to update field");
                builderWhere.append(String.format("WHERE %s = ?", columName));
                primaryKey = Optional.of(value);
                continue;
            }
            if(declaredField.isAnnotationPresent(ColumnInfo.class))
            {
                if(value == null) continue;
                var columName = declaredField.getAnnotation(ColumnInfo.class).name();
                builder.append(String.format("%s = ?,", columName));
                params.add(value);
            }
        }
        builder = new StringBuilder(builder.substring(0, builder.length() - 1));
        builder.append(" ").append(builderWhere).append(";");
        System.out.println(builder);
        System.out.println(primaryKey.get());
        String sql = builder.toString();
        var st = connection.prepareStatement(sql);
        int index = 0;
        while (index < params.size())
        {
            System.out.println(index+1 + " " + params.get(index));
            st.setObject(index+1, params.get(index));
            index++;
        }
        st.setObject(index+1, primaryKey.get());
        System.out.println(sql);
        return st.execute();
    }

    private Object deleteOne(Object proxy, Method method, Object[] args) throws IllegalAccessException, SQLException {
        if(args.length != 1) throw new RuntimeException(method.getName()+ " must receive just one parameter");
        Connection connection = Cat.getConnection();
        StringBuilder builder = new StringBuilder();
        var item = args[0];
        if(item == null) throw new RuntimeException("The parameter of " + method.getName() + "doesn't have to be null");
        if(!item.getClass().isAnnotationPresent(Entity.class)) throw new RuntimeException(" the parameter of " + method.getName() + " needs to be an entity");
        var tableName = item.getClass().getAnnotation(Entity.class).value();
        var declaredFields = item.getClass().getDeclaredFields();
        Optional<Object> primaryKey = Optional.empty();
        builder.append(String.format("DELETE FROM %s WHERE", tableName));
        for(var declaredField : declaredFields)
        {
            declaredField.setAccessible(true);
            var value = declaredField.get(item);
            if(declaredField.isAnnotationPresent(PrimaryKey.class) && declaredField.isAnnotationPresent(ColumnInfo.class))
            {
                if(value != null) {
                    primaryKey = Optional.of(value);
                    builder.append(String.format(" %s = ?", declaredField.getAnnotation(ColumnInfo.class).name()));
                    break;
                }
            }
        }
        if(primaryKey.isEmpty()) throw new RuntimeException("primary key is null you can't update");
        String sql = builder.toString();
        System.out.println(sql);
        var st = connection.prepareStatement(sql);
        st.setObject(1,primaryKey.get());
        return st.execute();
    }
    private Object insertOne(Object proxy, Method method, Object[] args) throws Throwable {
        if(args.length != 1) throw new RuntimeException(method.getName()+ " must receive just one parameter");
        Connection connection = Cat.getConnection();
        StringBuilder builder = new StringBuilder();
        StringBuilder paramsBuilder = new StringBuilder();
        var item = args[0];
        if(item == null) throw new RuntimeException("The parameter of " + method.getName() + "doesn't have to be null");
        if(!item.getClass().isAnnotationPresent(Entity.class)) throw new RuntimeException(" the parameter of " + method.getName() + " needs to be an entity");
        var tableName = item.getClass().getAnnotation(Entity.class).value();
        var declaredFields = item.getClass().getDeclaredFields();
        builder.append(String.format("INSERT INTO %s (", tableName));
        paramsBuilder.append("VALUES(");

        ArrayList<Object> values = new ArrayList<>();
        for(var declaredField : declaredFields)
        {
            declaredField.setAccessible(true);
            var value = declaredField.get(item);
            if(declaredField.isAnnotationPresent(PrimaryKey.class))
            {
                var pkAnotation = declaredField.getAnnotation(PrimaryKey.class);
                if(pkAnotation.autoIncrement()) continue;
                else if(value == null) throw new Exception(declaredField.getName() + "doesn't have to be null because is a primary key");
            }
            if(declaredField.isAnnotationPresent(ColumnInfo.class))
            {
                var columName = declaredField.getAnnotation(ColumnInfo.class).name();
                builder.append(String.format("%s,", columName));
                paramsBuilder.append("?,");
                values.add(value);
            }
        }
        builder = new StringBuilder(builder.substring(0, builder.length() - 1));
        paramsBuilder = new StringBuilder(paramsBuilder.substring(0, paramsBuilder.length()-1));
        builder.append(") ");
        paramsBuilder.append(");");
        String sql = builder.append(paramsBuilder).toString();
        var st = connection.prepareStatement(sql);
        for (int i = 0; i < values.size(); i++)
        {
            st.setObject(i+1, values.get(i));
        }
        return st.execute();
    }

    private Object getMany(Object proxy, Method method, Object[] args) throws Throwable
    {
        String query = method.getAnnotation(Query.class).value();
        if (query == null) throw new Error(Query.class.getName() + " is not implemented in " + method.getName());
        StringBuilder queryBuilder = new StringBuilder(query);
        Connection connection = Cat.getConnection();
        Type returnType = method.getGenericReturnType();
        if(args != null)
        {
            for (var param : method.getParameters())
            {
                if (param.isAnnotationPresent(P.class))
                {
                    queryBuilder = new StringBuilder(queryBuilder.toString().replace(String.format(":%s", param.getAnnotation(P.class).value()), "?"));
                }

            }
            System.out.println(queryBuilder);
        }
        if(returnType instanceof ParameterizedType)
        {
            ParameterizedType parameterizedType = (ParameterizedType) returnType;
            Type actualType = parameterizedType.getActualTypeArguments()[0];

            if (!(actualType instanceof Class<?> entityClass)) {
                throw new IllegalArgumentException("Cannot determine the entity class from generic return type.");
            }

            var st = connection.prepareStatement(queryBuilder.toString());
            if(args !=  null)
            {
                int i = 1;
                for(var arg : args)
                {
                    st.setObject(i,arg);
                    i++;
                }
            }
            ResultSet rs = st.executeQuery();
            ResultSetMetaData metaData = rs.getMetaData();
            var constructorEntity = entityClass.getDeclaredConstructor();

            List<Object> res = new ArrayList<>();
            while (rs.next()) {
                constructorEntity.setAccessible(true);
                var entityInstance = constructorEntity.newInstance();
                for (var field : ((Class<?>) actualType).getDeclaredFields()) {

                    String columnName = field.getAnnotation(ColumnInfo.class).name();
                    var value = rs.getObject(columnName);
                    field.setAccessible(true);
                    field.set(entityInstance,value);

                }
                res.add(entityInstance);
            }
            return res;
        }

        return null;
    }
}
